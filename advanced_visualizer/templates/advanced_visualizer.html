<style>
.node {
  cursor: pointer;
  color: #3182bd;

}

.link {
  fill: none;
  stroke: #9ecae1;
  stroke-width: 1.5px;
}

#main-svg-{{name}} {
    width: 100%;
    height: 100%;
}

.active-node {
    stroke: black;
    stroke-width: 1px;
}

</style>
<script src="https://d3js.org/d3.v3.js"></script>
<script>
    function nodeClick(el){
        d3.select(".active-node").select("circle").style("fill","white");
        d3.select(".active-node").classed("active-node",false);
        d3.select(el).classed("active-node",true);
        d3.select(el).select("circle").style("fill","red");
    }
</script>
<svg id="main-svg-{{name}}">

</svg>
<script>
    var nodes={
        {% for n in nodes %}
            "node_{{n.id}}": {
                name: "node_{{n.id}}",
                    data: {{ n.data | tojson }},
            },
        {% endfor %}
    };

    var links=[
        {% for e in edges %}
            {source: "node_{{e.src.id}}", target: "node_{{e.dest.id}}", data: {{e.data | tojson}}},
        {% endfor %}
    ];

    links.forEach(function(link) {
        link.source = nodes[link.source];
        link.target = nodes[link.target];
    });

    var g = d3.select('#main-svg-{{name}}')
        .call(d3.behavior.zoom().on("zoom", function () {
            // Svaki put prilikom okidanja dogadjaja zoom-a (npr. rotacija tockica misa),
            // poziva se ova funkcija koja radi translaciju i skaliranje na osnovu
            // parametara koje cita iz dogadjaja
            console.log("okida se dogadjaj")
            g.attr("transform", "translate(" + d3.event.translate + ")" + " scale(" + d3.event.scale + ")")
        }))
        .append('g');


    // Force layout vrsi numericku simulaciju n-tela (n-cestica).
    // https://d3-wiki.readthedocs.io/zh_CN/master/Force-Layout/
    var force = d3.layout.force() // kreiranje force layout-a
        .size([700, 700]) // raspoloziv prostor za iscrtavanje
        .nodes(d3.values(nodes)) // dodavanje informacija o cvorovima grafa
        .links(links) // dodavanje informacije o ivicama grafa
        .on("tick", tick) // Dogadjaj tick okida se prilikokm svakog koraka simulacije.
                          // Tada se poziva dolenavedena "tick" funckija koja koriguje pozicije
                          // elemenata grafa.
                          // Vise informacija mozete pronaci ovde:
                          // https://d3-wiki.readthedocs.io/zh_CN/master/Force-Layout/#tick
        .linkDistance(400) // duzina ivice grafa
        .charge(-100) // koliko da se elementi odbijaju (pozitivna vrednost kaze koliko se elementi privlace)
        .gravity(0.02) // Set gravity to 0 to prevent nodes from gravitating towards the center.
        .start(); //pokreni simulaciju

    var drag = d3.behavior.drag()
    .on("dragstart", function() { d3.event.sourceEvent.stopPropagation(); })
    .on("drag", function() { /* handle drag event here */ });

    var drag = force.drag()
        .on("dragstart", function() { d3.event.sourceEvent.stopPropagation(); });

    console.log(force.nodes());

    // Initialize a map to track links between the same nodes
    var linkCounts = {};

    links.forEach(function(link) {
        var key = link.source.id + "-" + link.target.id;
        var reverseKey = link.target.id + "-" + link.source.id;

        if (!linkCounts[key] && !linkCounts[reverseKey]) {
            linkCounts[key] = 0;
        }

        linkCounts[key]++;
        link.index = linkCounts[key];
    });

    // Function to generate a path for each link
    function linkPath(d) {
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy) * d.index; // Increase the curvature based on the link's index

        return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
    }

    // Stvarno iscrtavanje linkova koji su prikazani linijama.
    var link = g.selectAll('.link')
        .data(links)
        .enter().append('path')
        .attr('class', 'link')
        .style('stroke-width', function(d) {
            return d.data.weight ? 1 + d.data.weight * 0.5 : 1; // Default stroke width is 1 if weight is not defined
        });

    // Stvarno iscrtavanje cvorova reprezentovanih g tagom.
    var node = g.selectAll('.node')
        .data(force.nodes()) //add
        .enter().append('g')
        .attr('class', 'node')
        .attr('id', function(d){return d.name;})
        .on('click',function(){
           nodeClick(this);
        });

    var rectWidth = 100; // Width of the rectangle
    var initialRectHeight = 30; // Initial height of the rectangle
    var textSize = 12; // Size of the text
    var lineSpacing = 15; // Spacing between lines of text

    node.each(function(d) {
        var nodeGroup = d3.select(this);
        var keys = Object.keys(d.data);

        var totalTextLines = 1 + keys.length; // 1 for the name, rest for data keys
        var totalHeightNeeded = textSize + (totalTextLines * lineSpacing);

        // Adjust the rectangle height to fit all text
        var rectHeight = Math.max(initialRectHeight, totalHeightNeeded + 10); // Add some padding

        // Append rectangle
        nodeGroup.append('rect')
            .attr('width', rectWidth)
            .attr('height', rectHeight)
            .attr('x', -rectWidth / 2)
            .attr('y', -rectHeight / 2)
            .style('fill', 'white')
            .style('stroke', 'black')
            .style('stroke-width', '1.5px');

        var startYPosition = -rectHeight / 2 + (rectHeight - totalHeightNeeded) / 2 + textSize;

        // Append name text first
        nodeGroup.append('text')
            .attr('text-anchor', 'middle')
            .attr('x', 0)
            .attr('y', startYPosition)
            .attr('font-size', textSize + 'px')
            .attr('font-family', 'sans-serif')
            .attr('fill', '#9ecae1')
            .text(d.name);

        // Append data texts below the name text
        keys.forEach((key, index) => {
            nodeGroup.append('text')
                .attr('text-anchor', 'middle')
                .attr('x', 0)
                .attr('y', startYPosition + (lineSpacing * (index + 1)))
                .attr('font-size', textSize + 'px')
                .attr('font-family', 'sans-serif')
                .attr('fill', 'black')
                .text(key + ": " + d.data[key]);
        });
    });


    function tick(e) {
        // Korak simulacije koji koriguje pozicije cvorova i ivica grafa.

        // translacija cvorova
        node.attr("transform", function(d) {
            return "translate(" + d.x + "," + d.y + ")";
        })
            // Omogucavamo interaktivno prevlacenje cvorova.
            // Vise informacija na
            // https://d3-wiki.readthedocs.io/zh_CN/master/Force-Layout/#drag
            .call(force.drag);

        // Korekcija pozicija ivica (linkova)
         link.attr('d', linkPath);
    }

</script>