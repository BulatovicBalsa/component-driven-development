<style>
    #bird-view-content {
        width: 100%;
        height: 100%;
    }

    #bird-view-svg {
        width: 100%;
        height: 100%;
    }

    #viewport-overlay {
        fill: rgba(255, 255, 255, 0.5);
        stroke: rgb(128, 128, 128);
    }

</style>
<div id="bird-view-content">
    <svg id="bird-view-svg">
        <!-- Your SVG content here, scaled appropriately -->
        <rect id="viewport-overlay" width="100" height="50"/>
    </svg>
</div>
<script>
    document.getElementById('bird-view-content').addEventListener('click', function(event) {
        const birdViewRect = this.getBoundingClientRect();
        const clickX = event.clientX - birdViewRect.left;
        const clickY = event.clientY - birdViewRect.top;

        // Assuming birdViewRect.width and birdViewRect.height represent the full extent
        // of the visualization in the bird's eye view
        const birdViewWidth = document.getElementById('bird-view-svg').clientWidth;
        const birdViewHeight = document.getElementById('bird-view-svg').clientHeight;

        // Calculate the ratio based on dimensions
        const ratioX = clickX / birdViewRect.width;
        const ratioY = clickY / birdViewRect.height;

        // Apply this ratio to the main view dimensions
        // Assuming you have a mechanism to scroll or change the viewport of the main view
        // This might be scrolling an overflow container, adjusting an SVG viewBox, or panning a canvas
        scrollToMainView(ratioX * birdViewWidth, ratioY * birdViewHeight);
    });

    function scrollToMainView(x, y) {
        const svgElement = document.getElementById('main-svg-advanced-visualizer');

        const currentViewBox = svgElement.getAttribute('viewBox');
        let viewWidth, viewHeight;
        if (currentViewBox) {
            const viewBoxValues = currentViewBox.split(' ');
            viewWidth = viewBoxValues[2];
            viewHeight = viewBoxValues[3];
        } else {
            viewWidth = 500;
            viewHeight = 300;
        }

        svgElement.setAttribute('viewBox', `${x} ${y} ${viewWidth} ${viewHeight}`);
    }

    function updateViewportOverlay() {
        const mainView = document.getElementById('main-view'); // Adjust based on your implementation
        const birdViewSvg = document.getElementById('bird-view-svg');

        const overlay = document.getElementById('viewport-overlay');
        const ratioX = mainView.scrollLeft / mainView.scrollWidth;
        const ratioY = mainView.scrollTop / mainView.scrollHeight;
        const ratioWidth = mainView.clientWidth / mainView.scrollWidth;
        const ratioHeight = mainView.clientHeight / mainView.scrollHeight;

        overlay.setAttribute('x', ratioX * birdViewSvg.clientWidth);
        overlay.setAttribute('y', ratioY * birdViewSvg.clientHeight);
        overlay.setAttribute('width', ratioWidth * birdViewSvg.clientWidth);
        overlay.setAttribute('height', ratioHeight * birdViewSvg.clientHeight);
    }

    var overlay = document.getElementById('viewport-overlay');
    var svg = document.getElementById('bird-view-svg');

    console.log(overlay);

    // Variables to keep track of dragging state
    var isDragging = false;
    var startX, startY;

    // Function to start dragging
    function startDrag(event) {
        // Ensure 'svg' references the DOM element, not a D3 selection
        var svgElement = svg.node(); // This gets the actual DOM element from the D3 selection
        var rect = svgElement.getBoundingClientRect(); // Now you can call getBoundingClientRect
        startX = event.clientX - rect.left - overlay.x.baseVal.value;
        startY = event.clientY - rect.top - overlay.y.baseVal.value;
        isDragging = true;
    }

    // Function to drag the overlay
    function drag(event) {
        if (isDragging) {
            var svgElement = svg.node(); // This gets the actual DOM element from the D3 selection
            var rect = svgElement.getBoundingClientRect(); // Now you can call getBoundingClientRect
            // Calculate the new position
            var newX = event.clientX - rect.left - startX;
            var newY = event.clientY - rect.top - startY;

            // Update the overlay's position
            overlay.setAttribute('x', newX);
            overlay.setAttribute('y', newY);

            // Optionally, update the main view's viewport here
        }
    }

    // Function to stop dragging
    function stopDrag() {
        isDragging = false;
    }

    // Attach event listeners
    overlay.addEventListener('mousedown', startDrag);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', stopDrag);

    var svgRect = svg.getBoundingClientRect(); // Get the bounding rectangle of the SVG

    // Function to zoom the overlay
    function zoom(event) {
        event.preventDefault();
        console.log("ZOOM");

        var zoomIntensity = 0.1;
        var scaleAmount = event.deltaY > 0 ? 1 + zoomIntensity : 1 - zoomIntensity;

        let currentWidth = overlay.width.baseVal.value;
        let currentHeight = overlay.height.baseVal.value;

        let newWidth = currentWidth * scaleAmount;
        let newHeight = currentHeight * scaleAmount;

        const minWidth = 30;
        const minHeight = 10;
        const svgElement = document.getElementById('main-svg-advanced-visualizer');
        const maxWidth = svgElement.clientWidth;
        const maxHeight = svgElement.clientHeight;

        // Clamp the new dimensions to be within the min and max limits
        newWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
        newHeight = Math.max(minHeight, Math.min(newHeight, maxHeight));

        let dx = (currentWidth - newWidth) / 2;
        let dy = (currentHeight - newHeight) / 2;

        let currentX = overlay.x.baseVal.value + dx;
        let currentY = overlay.y.baseVal.value + dy;

        console.log(newWidth, newHeight, currentX, currentY);

        overlay.setAttribute('width', newWidth);
        overlay.setAttribute('height', newHeight);

        overlay.setAttribute('x', currentX);
        overlay.setAttribute('y', currentY);

        const viewBox = svgElement.getAttribute('viewBox').split(' ').map(Number);
        const [x, y, width, height] = viewBox;

        // Calculate the new viewBox dimensions to reflect the zoom level
        const centerX = x + width / 2;
        const centerY = y + height / 2;
        const newViewBoxWidth = width * scaleAmount;
        const newViewBoxHeight = height * scaleAmount;
        const newX = centerX - newViewBoxWidth / 2;
        const newY = centerY - newViewBoxHeight / 2;

        console.log(newX, newY, newViewBoxWidth, newViewBoxHeight);

        const clampedViewBoxWidth = Math.max(minWidth, Math.min(newViewBoxWidth, maxWidth));
        const clampedViewBoxHeight = Math.max(minHeight, Math.min(newViewBoxHeight, maxHeight));

        svgElement.setAttribute('viewBox', `${newX} ${newY} ${clampedViewBoxWidth} ${clampedViewBoxHeight}`);
    }

    svg.addEventListener('wheel', zoom);

    mainView.addEventListener('scroll', updateViewportOverlay);
</script>